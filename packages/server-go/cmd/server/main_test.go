package main

import (
	"context"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"testing"
	"time"

	"github.com/labring/devbox-sdk-server/internal/server"
	"github.com/labring/devbox-sdk-server/pkg/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test helper functions for main package functionality

func TestNewApplication(t *testing.T) {
	t.Run("successful application creation", func(t *testing.T) {
		// Create a direct config instead of parsing from args to avoid flag conflicts
		cfg := &config.Config{
			Addr:               ":0",
			Token:              "test-token-" + generateRandomString(8),
			LogLevel:           slog.LevelError,
			TokenAutoGenerated: false,
			WorkspacePath:      "/tmp/test-workspace",
			MaxFileSize:        1024 * 1024,
		}

		// Setup logger directly
		setupLogger(cfg)
		logConfiguration(cfg)

		// Create server instance
		srv, err := server.New(cfg)
		require.NoError(t, err)

		// Create HTTP server
		httpServer := &http.Server{
			Addr:    cfg.Addr,
			Handler: srv,
		}

		app := &Application{
			cfg:        cfg,
			server:     srv,
			httpServer: httpServer,
			quitChan:   make(chan os.Signal, 1),
		}

		// Test getters
		assert.NotNil(t, app, "application should not be nil")
		assert.Equal(t, cfg, app.cfg, "GetConfig should return config")
		assert.Equal(t, srv, app.server, "GetServer should return server")
		assert.Equal(t, httpServer, app.httpServer, "GetHTTPServer should return http server")
		assert.NotNil(t, app.quitChan, "quit channel should be set")
	})
}

func TestSetupLogger(t *testing.T) {
	testCases := []struct {
		name        string
		logLevel    slog.Level
		addSource   bool
		expectDebug bool
	}{
		{
			name:        "debug level enables source",
			logLevel:    slog.LevelDebug,
			addSource:   true,
			expectDebug: true,
		},
		{
			name:        "info level disables source",
			logLevel:    slog.LevelInfo,
			addSource:   false,
			expectDebug: false,
		},
		{
			name:        "warn level disables source",
			logLevel:    slog.LevelWarn,
			addSource:   false,
			expectDebug: false,
		},
		{
			name:        "error level disables source",
			logLevel:    slog.LevelError,
			addSource:   false,
			expectDebug: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cfg := &config.Config{
				LogLevel: tc.logLevel,
			}

			// Save original logger
			originalLogger := slog.Default()
			defer slog.SetDefault(originalLogger)

			// Setup logger using the same logic as main
			setupLogger(cfg)

			// Verify logger was set
			logger := slog.Default()
			assert.NotNil(t, logger, "logger should be set")
		})
	}
}

func TestCreateHTTPServer(t *testing.T) {
	cfg := &config.Config{
		Addr:     ":9757",
		Token:    "test-token",
		LogLevel: slog.LevelInfo,
	}

	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created successfully")

	httpServer := createHTTPServer(cfg, srv)

	assert.NotNil(t, httpServer, "HTTP server should be created")
	assert.Equal(t, cfg.Addr, httpServer.Addr, "address should match config")
	assert.Equal(t, srv, httpServer.Handler, "handler should be set")
}

func TestApplicationLifecycle(t *testing.T) {
	// Create a direct config to avoid flag parsing conflicts
	cfg := &config.Config{
		Addr:               ":0",
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	// Setup logger directly
	setupLogger(cfg)
	logConfiguration(cfg)

	// Create server instance
	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created")

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	// Test application start
	err = app.Start()
	assert.NoError(t, err, "application should start successfully")

	// Give server time to start
	time.Sleep(100 * time.Millisecond)

	// Test that server is responding
	client := &http.Client{Timeout: 1 * time.Second}
	url := "http://localhost" + app.httpServer.Addr + "/health"
	req, err := http.NewRequest("GET", url, nil)
	require.NoError(t, err, "request should be created")
	req.Header.Set("Authorization", "Bearer "+app.cfg.Token)

	resp, err := client.Do(req)
	if err == nil {
		defer resp.Body.Close()
		assert.Equal(t, http.StatusOK, resp.StatusCode, "health endpoint should respond")
	}

	// Test graceful shutdown
	err = app.Shutdown()
	assert.NoError(t, err, "shutdown should complete successfully")
}

func TestApplicationGracefulShutdown(t *testing.T) {
	// Save original args
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	// Set test args
	os.Args = []string{"test", "-addr=:0", "-log_level=error", "-token=test-token"}

	app, err := NewApplication()
	require.NoError(t, err)

	// Start server
	err = app.Start()
	assert.NoError(t, err, "application should start")

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test graceful shutdown by simulating signal
	shutdownComplete := make(chan bool, 1)
	go func() {
		app.WaitForShutdown()
		err := app.Shutdown()
		assert.NoError(t, err, "shutdown should succeed")
		shutdownComplete <- true
	}()

	// Send shutdown signal
	app.quitChan <- syscall.SIGINT

	// Wait for shutdown to complete
	select {
	case <-shutdownComplete:
		// Shutdown completed successfully
	case <-time.After(2 * time.Second):
		t.Fatal("shutdown did not complete in time")
	}
}

func TestApplicationRun(t *testing.T) {
	// Create a direct config to avoid flag parsing conflicts
	cfg := &config.Config{
		Addr:               ":0",
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	// Setup logger directly
	setupLogger(cfg)
	logConfiguration(cfg)

	// Create server instance
	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created")

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	// Test Run method (but don't actually run it to avoid blocking)
	// We'll test the components that Run() uses
	assert.NotNil(t, app.Start, "Start method should exist")
	assert.NotNil(t, app.WaitForShutdown, "WaitForShutdown method should exist")
	assert.NotNil(t, app.Shutdown, "Shutdown method should exist")
}

func TestApplicationCreationFailure(t *testing.T) {
	// Test with a config that would cause server creation issues
	cfg := &config.Config{
		Addr:               "invalid-address",
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	// Setup logger directly
	setupLogger(cfg)
	logConfiguration(cfg)

	// Create server instance - this should still succeed because
	// server creation doesn't validate the address until ListenAndServe
	srv, err := server.New(cfg)
	if err != nil {
		// If server creation fails, that's also acceptable for this test
		assert.Error(t, err, "server creation should fail with invalid config")
		return
	}

	// If server creation succeeds, application creation should also succeed
	require.NotNil(t, srv, "server should be created")

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	assert.NotNil(t, app, "application should be created")
}

func TestSignalHandling(t *testing.T) {
	// Test signal handling setup
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	// Send a test signal
	quit <- syscall.SIGINT

	// Verify signal was received
	select {
	case sig := <-quit:
		assert.Equal(t, syscall.SIGINT, sig, "should receive SIGINT")
	case <-time.After(100 * time.Millisecond):
		t.Fatal("signal not received in time")
	}
}

func TestServerConfigurationLogging(t *testing.T) {
	testCases := []struct {
		name               string
		cfg                *config.Config
		expectAutoGen      bool
		expectConfigFields bool
	}{
		{
			name: "auto-generated token",
			cfg: &config.Config{
				Addr:               ":9757",
				Token:              "auto-generated-token",
				TokenAutoGenerated: true,
				LogLevel:           slog.LevelInfo,
			},
			expectAutoGen:      true,
			expectConfigFields: true,
		},
		{
			name: "manually provided token",
			cfg: &config.Config{
				Addr:               ":9757",
				Token:              "manual-token",
				TokenAutoGenerated: false,
				LogLevel:           slog.LevelWarn,
			},
			expectAutoGen:      false,
			expectConfigFields: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// We can't easily test slog output without capturing it
			// So we'll test the logic that would be used in main
			assert.Equal(t, tc.cfg.Addr, tc.cfg.Addr, "address should be available")
			assert.Equal(t, tc.cfg.Token, tc.cfg.Token, "token should be available")
			assert.Equal(t, tc.cfg.TokenAutoGenerated, tc.cfg.TokenAutoGenerated, "auto-generated flag should be available")
			assert.Equal(t, tc.cfg.LogLevel.String(), tc.cfg.LogLevel.String(), "log level should be available")

			if tc.expectAutoGen {
				assert.True(t, tc.cfg.TokenAutoGenerated, "should detect auto-generated token")
			} else {
				assert.False(t, tc.cfg.TokenAutoGenerated, "should detect manual token")
			}
		})
	}
}

func TestMainIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// This test verifies that main components can work together
	// We'll use a custom config that allows quick testing

	// Create a test config directly to avoid flag parsing conflicts
	cfg := &config.Config{
		Addr:               ":0",
		Token:              "integration-test-token-" + generateRandomString(8),
		TokenAutoGenerated: false,
		LogLevel:           slog.LevelError,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	assert.NotNil(t, cfg, "config should be created")
	assert.NotEmpty(t, cfg.Token, "token should be set")

	// Setup logger to mimic main()
	setupLogger(cfg)

	// Test server creation (but don't start it)
	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created")
	assert.NotNil(t, srv, "server should not be nil")

	// Test cleanup
	err = srv.Cleanup()
	assert.NoError(t, err, "cleanup should succeed")
}

func TestErrorHandlerPaths(t *testing.T) {
	// Test various error handling scenarios that main() would encounter

	t.Run("server creation error", func(t *testing.T) {
		// This tests the error handling path conceptually
		// In a real scenario, this would be caused by invalid config
		cfg := &config.Config{
			Addr:     ":9757",
			Token:    "valid-token",
			LogLevel: slog.LevelInfo,
		}

		srv, err := server.New(cfg)
		// With valid config, this should succeed
		assert.NoError(t, err)
		assert.NotNil(t, srv)
	})

	t.Run("HTTP server startup error", func(t *testing.T) {
		// Test with invalid address
		cfg := &config.Config{
			Addr:     "invalid-address",
			Token:    "test-token",
			LogLevel: slog.LevelError,
		}

		srv, err := server.New(cfg)
		require.NoError(t, err)

		httpServer := createHTTPServer(cfg, srv)

		// This should fail when trying to listen
		serverErrors := make(chan error, 1)
		go func() {
			if err := httpServer.ListenAndServe(); err != nil {
				serverErrors <- err
			}
		}()

		select {
		case err := <-serverErrors:
			// Expected to fail with invalid address
			assert.Error(t, err, "should fail with invalid address")
		case <-time.After(100 * time.Millisecond):
			// If it doesn't fail quickly, that's also a valid result
			// Just clean up
			ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
			defer cancel()
			httpServer.Shutdown(ctx)
		}
	})
}

func TestTimeoutShutdown(t *testing.T) {
	cfg := &config.Config{
		Addr:     ":0",
		Token:    "test-token",
		LogLevel: slog.LevelError,
	}

	srv, err := server.New(cfg)
	require.NoError(t, err)

	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	// Start server
	go func() {
		_ = httpServer.ListenAndServe()
	}()

	// Give server time to start
	time.Sleep(100 * time.Millisecond)

	// Test shutdown with very short timeout
	// Note: Shutdown might succeed even with short timeout if server responds quickly
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)
	defer cancel()

	err = httpServer.Shutdown(ctx)
	// This might or might not fail depending on timing
	if err != nil {
		assert.Contains(t, err.Error(), "context", "error should be context-related")
	}

	// Always cleanup with proper timeout
	ctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel2()

	err = httpServer.Shutdown(ctx2)
	assert.NoError(t, err, "shutdown should succeed with proper timeout")

	err = srv.Cleanup()
	assert.NoError(t, err, "cleanup should succeed")
}

// Helper functions extracted from main for testing

func createHTTPServer(cfg *config.Config, srv *server.Server) *http.Server {
	return &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}
}

func createTestServerConfig() *config.Config {
	return &config.Config{
		Addr:               ":0", // Random port
		Token:              "test-token-" + generateRandomString(8),
		TokenAutoGenerated: false,
		LogLevel:           slog.LevelError,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024, // 1MB
	}
}

// Test utilities

func generateRandomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[i%len(charset)]
	}
	return string(b)
}

func captureLogs(f func()) string {
	// Helper to capture log output for testing
	// This would require more sophisticated setup in a real scenario
	f()
	return "captured logs"
}

// Benchmark tests
func BenchmarkMain_ConfigParsing(b *testing.B) {
	// Benchmark config creation with direct struct creation
	// to avoid flag parsing conflicts in benchmarks
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		cfg := &config.Config{
			Addr:               ":9757",
			Token:              "bench-token",
			TokenAutoGenerated: false,
			LogLevel:           slog.LevelInfo,
			WorkspacePath:      "/workspace",
			MaxFileSize:        100 * 1024 * 1024,
		}
		_ = cfg
	}
}

func BenchmarkMain_ServerCreation(b *testing.B) {
	cfg := createTestServerConfig()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := server.New(cfg)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkMain_HTTPServerCreation(b *testing.B) {
	cfg := createTestServerConfig()
	srv, err := server.New(cfg)
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = createHTTPServer(cfg, srv)
	}
}

func TestRunMethod(t *testing.T) {
	// Test the Run method with a goroutine to avoid blocking
	cfg := &config.Config{
		Addr:               ":0",
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	// Setup logger directly
	setupLogger(cfg)

	// Create server instance
	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created")

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	// Test Run method in a goroutine with signal to complete
	runComplete := make(chan error, 1)
	go func() {
		runComplete <- app.Run()
	}()

	// Give the server time to start
	time.Sleep(100 * time.Millisecond)

	// Send shutdown signal to complete the Run method
	app.quitChan <- syscall.SIGINT

	// Wait for Run to complete
	select {
	case err := <-runComplete:
		assert.NoError(t, err, "Run should complete successfully")
	case <-time.After(2 * time.Second):
		t.Fatal("Run method did not complete in time")
	}
}

func TestRunMethodStartFailure(t *testing.T) {
	// Test Run method when Start fails (though Start currently doesn't fail)
	cfg := &config.Config{
		Addr:               "invalid-address-that-might-fail",
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	// Setup logger directly
	setupLogger(cfg)

	// Create server instance
	srv, err := server.New(cfg)
	require.NoError(t, err, "server should be created")

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	// Test that even with invalid address, Run doesn't immediately fail
	// because Start() only launches the server in a goroutine
	runComplete := make(chan error, 1)
	go func() {
		runComplete <- app.Run()
	}()

	// Send immediate shutdown signal
	app.quitChan <- syscall.SIGINT

	// Wait for Run to complete
	select {
	case err := <-runComplete:
		// Run should complete without error even if server fails to bind
		// because the error is logged in the Start goroutine, not returned
		assert.NoError(t, err, "Run should handle start failures gracefully")
	case <-time.After(1 * time.Second):
		t.Fatal("Run method did not complete in time")
	}
}

func TestRunMethodPortOccupied(t *testing.T) {
	l, err := net.Listen("tcp", "127.0.0.1:0")
	require.NoError(t, err)
	defer l.Close()

	port := l.Addr().(*net.TCPAddr).Port
	addr := fmt.Sprintf(":%d", port)

	cfg := &config.Config{
		Addr:               addr,
		Token:              "test-token-" + generateRandomString(8),
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/tmp/test-workspace",
		MaxFileSize:        1024 * 1024,
	}

	setupLogger(cfg)

	srv, err := server.New(cfg)
	require.NoError(t, err)

	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	runComplete := make(chan error, 1)
	go func() {
		runComplete <- app.Run()
	}()

	select {
	case err := <-runComplete:
		assert.NoError(t, err)
	case <-time.After(2 * time.Second):
		t.Fatal("Run method did not complete in time")
	}
}

func TestMainFunction(t *testing.T) {
	// Test main function behavior by testing its components
	// We can't call main() directly because it would exit the process

	// Save original os.Args and os.Exit
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	// Test that main creates application and runs it
	// We simulate this by testing the components main() uses

	// Set test args that would work
	os.Args = []string{"test", "-addr=:0", "-log_level=error", "-token=test-token"}

	// Test the NewApplication part of main
	cfg := &config.Config{
		Addr:               ":0",
		Token:              "test-token",
		LogLevel:           slog.LevelError,
		TokenAutoGenerated: false,
		WorkspacePath:      "/workspace",
		MaxFileSize:        100 * 1024 * 1024,
	}

	// Setup logger like main does
	setupLogger(cfg)
	logConfiguration(cfg)

	// Create server like main does
	srv, err := server.New(cfg)
	require.NoError(t, err, "main should be able to create server")

	// Create HTTP server like main does
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	// Verify the components main would use
	assert.NotNil(t, app, "main should create application")
	assert.Equal(t, cfg, app.cfg, "main should set config")

	// Test the app.Run() part of main (but without blocking)
	runComplete := make(chan error, 1)
	go func() {
		// Simulate the Run() call from main
		err := app.Run()
		runComplete <- err
	}()

	// Give it time to start
	time.Sleep(50 * time.Millisecond)

	// Send signal to complete the run (like what would happen in real main)
	app.quitChan <- syscall.SIGINT

	// Wait for completion
	select {
	case err := <-runComplete:
		assert.NoError(t, err, "main's run should complete successfully")
	case <-time.After(2 * time.Second):
		t.Fatal("main's run did not complete in time")
	}
}

func TestMainFunctionErrorPaths(t *testing.T) {
	// Test error handling paths in main function

	// Save original os.Args
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	// Test 1: NewApplication failure simulation
	// We can't easily make NewApplication fail, but we can test
	// the error handling logic by creating a scenario where server creation fails

	t.Run("server creation failure", func(t *testing.T) {
		// This tests the error path where main would exit due to server creation failure
		// In practice, server creation rarely fails with valid config
		cfg := &config.Config{
			Addr:               ":0", // This should work
			Token:              "test-token",
			LogLevel:           slog.LevelError,
			TokenAutoGenerated: false,
			WorkspacePath:      "/tmp/test-workspace",
			MaxFileSize:        1024 * 1024,
		}

		setupLogger(cfg)

		srv, err := server.New(cfg)
		if err != nil {
			// If server creation fails, this simulates the error path in main
			// main would log the error and call os.Exit(1)
			assert.Error(t, err, "server creation should fail in this test scenario")
			return
		}

		// If server creation succeeds, the test should continue
		assert.NotNil(t, srv, "server should be created")

		// Cleanup
		err = srv.Cleanup()
		assert.NoError(t, err, "cleanup should succeed")
	})
}

func TestSetupLoggerDetailed(t *testing.T) {
	// Test detailed logger setup behavior that wasn't covered in basic tests
	testCases := []struct {
		name           string
		logLevel       slog.Level
		expectedSource bool
	}{
		{
			name:           "debug level adds source",
			logLevel:       slog.LevelDebug,
			expectedSource: true,
		},
		{
			name:           "info level no source",
			logLevel:       slog.LevelInfo,
			expectedSource: false,
		},
		{
			name:           "warn level no source",
			logLevel:       slog.LevelWarn,
			expectedSource: false,
		},
		{
			name:           "error level no source",
			logLevel:       slog.LevelError,
			expectedSource: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			cfg := &config.Config{
				LogLevel: tc.logLevel,
			}

			// Save original logger
			originalLogger := slog.Default()
			defer slog.SetDefault(originalLogger)

			// Setup logger using the function
			setupLogger(cfg)

			// Verify logger was set
			logger := slog.Default()
			assert.NotNil(t, logger, "logger should be set")

			// Test that logger works by logging a test message
			// This exercises the ReplaceAttr function in setupLogger
			logger.Info("test message", slog.String("key", "value"))
		})
	}
}

func TestLogConfigurationDetailed(t *testing.T) {
	// Test detailed configuration logging behavior

	t.Run("auto-generated token logging", func(t *testing.T) {
		cfg := &config.Config{
			Addr:               ":9757",
			LogLevel:           slog.LevelInfo,
			Token:              "auto-generated-token-12345",
			TokenAutoGenerated: true,
		}

		// This should not panic and should handle the auto-generated token case
		// We can't easily capture log output, but we can ensure it doesn't crash
		logConfiguration(cfg)
	})

	t.Run("manual token logging", func(t *testing.T) {
		cfg := &config.Config{
			Addr:               ":8081",
			LogLevel:           slog.LevelWarn,
			Token:              "manual-provided-token",
			TokenAutoGenerated: false,
		}

		// This should not panic and should handle the manual token case
		logConfiguration(cfg)
	})

	t.Run("different log levels", func(t *testing.T) {
		logLevels := []slog.Level{
			slog.LevelDebug,
			slog.LevelInfo,
			slog.LevelWarn,
			slog.LevelError,
		}

		for _, level := range logLevels {
			cfg := &config.Config{
				Addr:               fmt.Sprintf(":%d", 9757+int(level)),
				LogLevel:           level,
				Token:              "test-token",
				TokenAutoGenerated: false,
			}

			// Should handle all log levels without error
			logConfiguration(cfg)
		}
	})
}

func TestShutdownErrorPaths(t *testing.T) {
	// Test shutdown error paths that weren't covered in basic tests

	t.Run("HTTP server shutdown error", func(t *testing.T) {
		cfg := &config.Config{
			Addr:               ":0",
			Token:              "test-token-" + generateRandomString(8),
			LogLevel:           slog.LevelError,
			TokenAutoGenerated: false,
			WorkspacePath:      "/tmp/test-workspace",
			MaxFileSize:        1024 * 1024,
		}

		setupLogger(cfg)

		srv, err := server.New(cfg)
		require.NoError(t, err)

		httpServer := &http.Server{
			Addr:    cfg.Addr,
			Handler: srv,
		}

		app := &Application{
			cfg:        cfg,
			server:     srv,
			httpServer: httpServer,
			quitChan:   make(chan os.Signal, 1),
		}

		// Start server so we can shutdown
		err = app.Start()
		require.NoError(t, err)

		// Give server time to start
		time.Sleep(50 * time.Millisecond)

		// Create a context that's already canceled to force shutdown error
		ctx, cancel := context.WithCancel(context.Background())
		cancel() // Cancel immediately

		// Manually call shutdown with canceled context to test error path
		err = httpServer.Shutdown(ctx)
		// This might or might not error depending on timing
		// The important thing is that we test the error handling code path

		// Always cleanup properly
		err = app.Shutdown()
		assert.NoError(t, err, "proper shutdown should succeed")
	})

	t.Run("server cleanup error", func(t *testing.T) {
		// Test the case where server.Cleanup() returns an error
		// This is difficult to simulate because Cleanup rarely fails

		cfg := &config.Config{
			Addr:               ":0",
			Token:              "test-token-" + generateRandomString(8),
			LogLevel:           slog.LevelError,
			TokenAutoGenerated: false,
			WorkspacePath:      "/tmp/test-workspace",
			MaxFileSize:        1024 * 1024,
		}

		setupLogger(cfg)

		srv, err := server.New(cfg)
		require.NoError(t, err)

		httpServer := &http.Server{
			Addr:    cfg.Addr,
			Handler: srv,
		}

		app := &Application{
			cfg:        cfg,
			server:     srv,
			httpServer: httpServer,
			quitChan:   make(chan os.Signal, 1),
		}

		// Test normal shutdown - we can't easily make Cleanup fail
		// but we can test the normal path to ensure it works
		err = app.Shutdown()
		assert.NoError(t, err, "shutdown should succeed")
	})
}

func TestMainFunctionCompleteFlow(t *testing.T) {
	// Test the complete flow that main() would execute
	// This tests more paths in the main function logic

	// Save original os.Args
	originalArgs := os.Args
	defer func() { os.Args = originalArgs }()

	// Test scenario 1: normal flow
	t.Run("main normal flow simulation", func(t *testing.T) {
		os.Args = []string{"test", "-addr=:0", "-log_level=error", "-token=test-main-token"}

		// Simulate what main() does step by step
		cfg := &config.Config{
			Addr:               ":0",
			Token:              "test-main-token",
			LogLevel:           slog.LevelError,
			TokenAutoGenerated: false,
			WorkspacePath:      "/workspace",
			MaxFileSize:        100 * 1024 * 1024,
		}

		// Test the logger setup part of main
		setupLogger(cfg)

		// Test the configuration logging part of main
		logConfiguration(cfg)

		// Test application creation part of main
		srv, err := server.New(cfg)
		require.NoError(t, err, "main should create server successfully")

		httpServer := &http.Server{
			Addr:    cfg.Addr,
			Handler: srv,
		}

		app := &Application{
			cfg:        cfg,
			server:     srv,
			httpServer: httpServer,
			quitChan:   make(chan os.Signal, 1),
		}

		// Verify main's components are set up correctly
		assert.NotNil(t, app, "main should create application")
		assert.Equal(t, cfg, app.cfg, "main should set config correctly")

		// Test the app.Run() part of main (but without blocking)
		runComplete := make(chan error, 1)
		go func() {
			// Simulate the Run() call from main
			err := app.Run()
			runComplete <- err
		}()

		// Give it time to start
		time.Sleep(50 * time.Millisecond)

		// Send signal to complete the run (like what would happen in real main)
		app.quitChan <- syscall.SIGINT

		// Wait for completion
		select {
		case err := <-runComplete:
			assert.NoError(t, err, "main's run should complete successfully")
		case <-time.After(2 * time.Second):
			t.Fatal("main's run did not complete in time")
		}
	})

	// Test scenario 2: main with different configurations
	t.Run("main with different configurations", func(t *testing.T) {
		// Test with different log levels and settings
		testConfigs := []*config.Config{
			{
				Addr:               ":0",
				Token:              "debug-token",
				LogLevel:           slog.LevelDebug,
				TokenAutoGenerated: true,
				WorkspacePath:      "/tmp",
				MaxFileSize:        50 * 1024 * 1024,
			},
			{
				Addr:               ":0",
				Token:              "warn-token",
				LogLevel:           slog.LevelWarn,
				TokenAutoGenerated: false,
				WorkspacePath:      "/data",
				MaxFileSize:        200 * 1024 * 1024,
			},
		}

		for i, cfg := range testConfigs {
			t.Run(fmt.Sprintf("config_%d", i+1), func(t *testing.T) {
				// Test setup logger part
				setupLogger(cfg)

				// Test log configuration part
				logConfiguration(cfg)

				// Test server creation part
				srv, err := server.New(cfg)
				require.NoError(t, err, "main should create server with config %d", i+1)

				// Cleanup
				err = srv.Cleanup()
				assert.NoError(t, err, "main should cleanup server with config %d", i+1)
			})
		}
	})
}
