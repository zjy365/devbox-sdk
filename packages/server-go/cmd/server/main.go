package main

import (
	"context"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/labring/devbox-sdk-server/internal/server"
	"github.com/labring/devbox-sdk-server/pkg/config"
)

// Application represents the main application structure
type Application struct {
	cfg        *config.Config
	server     *server.Server
	httpServer *http.Server
	quitChan   chan os.Signal
}

// NewApplication creates a new application instance
func NewApplication() (*Application, error) {
	cfg := config.ParseCfg()

	// Initialize slog default logger with JSON handler using effective log level
	setupLogger(cfg)

	logConfiguration(cfg)

	// Create server instance
	srv, err := server.New(cfg)
	if err != nil {
		return nil, err
	}

	// Create HTTP server
	httpServer := &http.Server{
		Addr:    cfg.Addr,
		Handler: srv,
	}

	app := &Application{
		cfg:        cfg,
		server:     srv,
		httpServer: httpServer,
		quitChan:   make(chan os.Signal, 1),
	}

	return app, nil
}

// setupLogger initializes the slog logger with the given configuration
func setupLogger(cfg *config.Config) {
	addSource := cfg.LogLevel == slog.LevelDebug
	h := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
		Level:     cfg.LogLevel,
		AddSource: addSource,
		ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {
			if a.Key == slog.TimeKey {
				return slog.String(a.Key, a.Value.Time().Format("2006-01-02T15:04:05.000Z07:00"))
			}
			return a
		},
	})
	slog.SetDefault(slog.New(h))
}

// logConfiguration logs the applied configuration
func logConfiguration(cfg *config.Config) {
	slog.Info("Config applied",
		slog.String("addr", cfg.Addr),
		slog.String("log_level", cfg.LogLevel.String()),
		slog.String("workspace_path", cfg.WorkspacePath),
	)

	if cfg.TokenAutoGenerated {
		slog.Warn("Auth token was auto-generated; store it securely.", slog.String("token", cfg.Token))
	} else {
		slog.Info("Auth token configured.")
	}
}

// Start starts the application server
func (app *Application) Start() error {
	// Start server in a goroutine
	go func() {
		slog.Info("Starting server", slog.String("addr", app.cfg.Addr))

		if err := app.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			slog.Error("Server failed to start", slog.String("error", err.Error()))
		}
	}()

	return nil
}

// WaitForShutdown waits for shutdown signals
func (app *Application) WaitForShutdown() {
	// Wait for interrupt signal to gracefully shutdown the server
	signal.Notify(app.quitChan, syscall.SIGINT, syscall.SIGTERM)
	<-app.quitChan
}

// Shutdown gracefully shuts down the application
func (app *Application) Shutdown() error {
	slog.Info("Shutting down server...")

	// Create a context with timeout for graceful shutdown
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Shutdown the HTTP server
	if err := app.httpServer.Shutdown(ctx); err != nil {
		slog.Error("Server forced to shutdown", slog.String("error", err.Error()))
		return err
	}

	// Cleanup server resources
	if err := app.server.Cleanup(); err != nil {
		slog.Error("Error during server cleanup", slog.String("error", err.Error()))
		return err
	}

	slog.Info("Server exited")
	return nil
}

// Run runs the complete application lifecycle
func (app *Application) Run() error {
	if err := app.Start(); err != nil {
		return err
	}

	app.WaitForShutdown()
	return app.Shutdown()
}

func main() {
	app, err := NewApplication()
	if err != nil {
		slog.Error("Failed to create application", slog.String("error", err.Error()))
		os.Exit(1)
	}

	if err := app.Run(); err != nil {
		slog.Error("Application failed", slog.String("error", err.Error()))
		os.Exit(1)
	}
}
